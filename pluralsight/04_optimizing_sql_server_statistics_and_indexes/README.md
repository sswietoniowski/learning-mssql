# Optimizing SQL Server Statistics and Indexes

Introduction to SQL Server Statistics and Indexes

## 1. Overview of Index Maintenance

We need to maintain our indexes to reduce its fragmentation also we might need to update statistics to improve query performance.

Maintenance:

- cleanup,
- out of peak time,
- determined by workload.

There are other maintenance tasks that we can (and should) do: backups and consistency checks.

## 2. Review Index Usage and Identify Potential Missing Indexes

Why do we need to maintain indexes?

Main reasons:

- workload changes,
- data changes,
- schema changes.

First we need to know how to review index usage:

- identify missing indexes,
- identify unused indexes,
- identify redundant indexes.

To identify missing indexes we can use:

- Dynamic Management Views (DMVs),
- Database Tuning Advisor (DTA).

They both produce **recommendations** which we should review (carefully) and implement (if really needed).

### Missing Indexes DMVs

Missing Index DMVs are:

- automatically tracked,
- generated by the Query Optimizer,
- limited in what is considered (compared to DTA),
- won't recommended clustered indexes, partitioning and columnstore indexes, unique constraints or unique indexes,

Missing Index DMVs objects:

- `sys.dm_db_missing_index_groups` - groups of missing indexes,
- `sys.dm_db_missing_index_group_stats` - statistics about missing indexes,
- `sys.dm_db_missing_index_details` - details about missing indexes.

To know whether we're missing some indexes we can use:

```sql
SELECT DB_NAME(mid.database_id) AS DatabaseName,
       OBJECT_SCHEMA_NAME(mid.object_id, mid.database_id) AS SchemaName,
       OBJECT_NAME(mid.object_id, mid.database_id) AS ObjectName,
       migs.avg_user_impact,
       mid.equality_columns,
       mid.inequality_columns,
       mid.included_columns
FROM sys.dm_db_missing_index_groups mig
    INNER JOIN sys.dm_db_missing_index_group_stats migs
        ON migs.group_handle = mig.index_group_handle
    INNER JOIN sys.dm_db_missing_index_details mid
        ON mig.index_handle = mid.index_handle;
```

Interpreting the results:

- `avg_user_impact` - average impact of the missing index on the query performance,
- `equality_columns` - columns used in the `WHERE` clause,
- `inequality_columns` - columns used in the `WHERE` clause with inequality operators,
- `included_columns` - columns used in the `SELECT` clause.

Recommendations are for the most part to create a covering index - as such they can be quite
expensive (if applied without proper review).

Limitations of Missing Index DMVs:

- can recommended partially duplicate indexes,
- evaluated per-query, not on entire workload,
- limited in how many suggestions are kept,
- lost when the server restarts.

### Database Tuning Advisor

> Database Tuning Advisor (DTA) is a tool that can help us with finding missing indexes.

DTA is a wizard that can be run from SQL Server Management Studio (SSMS).

DTA:

- tunes a query or a workload,
- tests out recommendations on target database (!),
- tends to over-recommend,

DTA Workflow:

1. **generate workload** (on your production database),
2. **analyze database** (don't perform on the production database),
3. **implement recommendations** (well - don't start from the production database and don't do that without review).

These 3 steps can be run separately on different instances.

Workload can be generated from:

- Query Store (recommended!),
- manual T-SQL scripts,
- Plan Cache,
- Profiler workload (also recommended for MSSQL <= 2014).

Limitations of DTA:

- requires a comprehensive workload for best results,
- adds load to target server,
- tends to badly over-recommend.

### Unused Indexes

Index Usage DMVs:

- `sys.dm_db_index_usage_stats` - index usage statistics.

`syst.dm_db_index_usage_stats`:

- tracks how the indexes are used,
- transient, data lost when server restarts,
- useful guideline.

To know (or at least got basic idea of) whether our indexes are used or not we can use:

```sql
SELECT OBJECT_NAME(i.object_id) AS TableName,
       i.index_id,
       ISNULL(user_seeks, 0) AS UserSeeks,
       ISNULL(user_scans, 0) AS UserScans,
       ISNULL(user_lookups, 0) AS UserLookups,
       ISNULL(user_updates, 0) AS UserUpdates
FROM sys.indexes i
    LEFT OUTER JOIN sys.dm_db_index_usage_stats ius
        ON ius.object_id = i.object_id AND ius.index_id = i.index_id
WHERE OBJECTPROPERTY(i.object_id, 'IsMSShipped') = 0;
```

Removing Unused Indexes:

| Pro                                                                               | Con                                                                    |
| --------------------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| Frees up space in the database                                                    | Requires extensive analysis                                            |
| Reduces overhead on data modifications                                            | Risk of missing a query that runs occasionally                         |
| Use automated application testing if possible, to ensure there has been no impact | Consider using Distributed Replay to rerun and test database workloads |

### Redundant Indexes



## 3. Maintaining Rowstore Indexes

## 4. Maintaining Columnstore Indexes

## 5. Maintaining Statistics

## Summary
