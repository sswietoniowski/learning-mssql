# Optimizing SQL Server Statistics and Indexes

Introduction to SQL Server Statistics and Indexes

## 1. Overview of Index Maintenance

We need to maintain our indexes to reduce its fragmentation also we might need to update statistics to improve query performance.

Maintenance:

- cleanup,
- out of peak time,
- determined by workload.

There are other maintenance tasks that we can (and should) do: backups and consistency checks.

## 2. Review Index Usage and Identify Potential Missing Indexes

Why do we need to maintain indexes?

Main reasons:

- workload changes,
- data changes,
- schema changes.

First we need to know how to review index usage:

- identify missing indexes,
- identify unused indexes,
- identify redundant indexes.

To identify missing indexes we can use:

- Dynamic Management Views (DMVs),
- Database Tuning Advisor (DTA).

They both produce **recommendations** which we should review (carefully) and implement (if really needed).

### Missing Indexes DMVs

Missing Index DMVs are:

- automatically tracked,
- generated by the Query Optimizer,
- limited in what is considered (compared to DTA),
- won't recommended clustered indexes, partitioning and columnstore indexes, unique constraints or unique indexes,

Missing Index DMVs objects:

- `sys.dm_db_missing_index_groups` - groups of missing indexes,
- `sys.dm_db_missing_index_group_stats` - statistics about missing indexes,
- `sys.dm_db_missing_index_details` - details about missing indexes.

To know whether we're missing some indexes we can use:

```sql
SELECT DB_NAME(mid.database_id) AS DatabaseName,
       OBJECT_SCHEMA_NAME(mid.object_id, mid.database_id) AS SchemaName,
       OBJECT_NAME(mid.object_id, mid.database_id) AS ObjectName,
       migs.avg_user_impact,
       mid.equality_columns,
       mid.inequality_columns,
       mid.included_columns
FROM sys.dm_db_missing_index_groups mig
    INNER JOIN sys.dm_db_missing_index_group_stats migs
        ON migs.group_handle = mig.index_group_handle
    INNER JOIN sys.dm_db_missing_index_details mid
        ON mig.index_handle = mid.index_handle;
```

Interpreting the results:

- `avg_user_impact` - average impact of the missing index on the query performance,
- `equality_columns` - columns used in the `WHERE` clause,
- `inequality_columns` - columns used in the `WHERE` clause with inequality operators,
- `included_columns` - columns used in the `SELECT` clause.

Recommendations are for the most part to create a covering index - as such they can be quite
expensive (if applied without proper review).

Limitations of Missing Index DMVs:

- can recommended partially duplicate indexes,
- evaluated per-query, not on entire workload,
- limited in how many suggestions are kept,
- lost when the server restarts.

### Database Tuning Advisor

> Database Tuning Advisor (DTA) is a tool that can help us with finding missing indexes.

DTA is a wizard that can be run from SQL Server Management Studio (SSMS).

DTA:

- tunes a query or a workload,
- tests out recommendations on target database (!),
- tends to over-recommend,

DTA Workflow:

1. **generate workload** (on your production database),
2. **analyze database** (don't perform on the production database),
3. **implement recommendations** (well - don't start from the production database and don't do that without review).

These 3 steps can be run separately on different instances.

Workload can be generated from:

- Query Store (recommended!),
- manual T-SQL scripts,
- Plan Cache,
- Profiler workload (also recommended for MSSQL <= 2014).

Limitations of DTA:

- requires a comprehensive workload for best results,
- adds load to target server,
- tends to badly over-recommend.

### Unused Indexes

Index Usage DMVs:

- `sys.dm_db_index_usage_stats` - index usage statistics.

`syst.dm_db_index_usage_stats`:

- tracks how the indexes are used,
- transient, data lost when server restarts,
- useful guideline.

To know (or at least got basic idea of) whether our indexes are used or not we can use:

```sql
SELECT OBJECT_NAME(i.object_id) AS TableName,
       i.index_id,
       ISNULL(user_seeks, 0) AS UserSeeks,
       ISNULL(user_scans, 0) AS UserScans,
       ISNULL(user_lookups, 0) AS UserLookups,
       ISNULL(user_updates, 0) AS UserUpdates
FROM sys.indexes i
    LEFT OUTER JOIN sys.dm_db_index_usage_stats ius
        ON ius.object_id = i.object_id AND ius.index_id = i.index_id
WHERE OBJECTPROPERTY(i.object_id, 'IsMSShipped') = 0;
```

Removing Unused Indexes:

| Pro                                                                               | Con                                                                    |
| --------------------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| Frees up space in the database                                                    | Requires extensive analysis                                            |
| Reduces overhead on data modifications                                            | Risk of missing a query that runs occasionally                         |
| Use automated application testing if possible, to ensure there has been no impact | Consider using Distributed Replay to rerun and test database workloads |

### Redundant Indexes

Redundant indexes are indexes that:

- have same key columns in the same order,
- key columns are left-based subset of another index.

To identify redundant indexes we can use:

```sql
SELECT OBJECT_SCHEMA_NAME(i.object_id) AS SchemaName,
       OBJECT_NAME(i.object_id) AS TableName,
       i.name,
       i.type_desc,
       STRING_AGG(c.name, ', ') WITHIN GROUP (ORDER BY key_ordinal) AS KeyCols,
FROM sys.indexes i
    INNER JOIN sys.index_columns ic
        ON ic.object_id = i.object_id
           AND ic.index_id = i.index_id
    INNER JOIN sys.columns c
        ON c.object_id = i.object_id
           AND c.column_id = ic.column_id
WHERE OBJECTPROPERTYEX(i.object_id, 'IsMSShipped') = 0
      AND ic.is_included_column = 0
GROUP BY i.object_id,
         i.name,
         i.type_desc;
```

## 3. Maintaining Rowstore Indexes

In case of rowstore indexes our main concern is fragmentation.

### Causes of Indexes Fragmentation

Why do we need to maintain indexes?

- to improve query performance,
- to improve data modification performance.

Index fragmentation is caused by:

- `INSERT` and `UPDATE` operations,
- `DELETE` operations.

Ideal Index:

- leaf level pages are full and leaf level pages are ordered.

Page Split Causes Fragmentation:

- `INSERT` and `UPDATE` operations.

Same is true for page deleted.

As a result we would have a fragmented index:

- leaf level pages are no longer full and leaf level pages are out of order (physical order doesn't match logical order).

That is why we need to perform index maintenance to restore its proper order.

### Effects of Fragmentation

Fragmentation effects:

- performance (degraded) - affects **large** range scans from **disk** (read-ahead is not possible),
  this problem is mostly visible on an OLAP system or the one with limited memory, it is relatively unlikely to see it on an OLTP system,
- space (increased) - partially empty pages means index takes up more space and thus it can cause higher memory usage.

In reality fragmentation isn't nearly as severe as is commonly believed.

### Identifying Fragmented Indexes

To identify fragmented indexes we can use:

```sql
SELECT OBJECT_SCHEMA_NAME(i.object_id) AS SchemaName, OBJECT_NAME(i.object_id) TableName,
    i.name,
    ips.partition_number,
    ips.index_type_desc,
    ips.index_level,
    ips.avg_fragmentation_in_percent,
    ips.page_count,
    ips.avg_page_space_used_in_percent
FROM sys.indexes i
    INNER JOIN sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'Limited') ips
        ON ips.object_id = i.object_id AND ips.index_id = i.index_id
WHERE ips.page_count > 1000
```

It is important to understand that `sys.dm_db_index_physical_stats` is not really a view, but it would
analyze the index and return the results. That is why it is important to use `LIMITED` option.

Important columns in the results:

- `avg_fragmentation_in_percent` - average fragmentation in percent,
- `avg_page_space_used_in_percent` - average page space used in percent.

### Fixing Fragmentation

To fix fragmentation we can use:

- `REORGANIZE` - reorganizes the index (shuffles the index pages back into order),
- `REBUILD` - rebuilds the index (recreates index, so it would take quite a long time to complete and can have significant impact on the transaction log).

To reorganize an index we can use:

```sql
ALTER INDEX <index_name> ON <table_name> REORGANIZE;
```

To rebuild an index we can use:

```sql
ALTER INDEX <index_name> ON <table_name> REBUILD;
```

Common industry practice is to rebuild indexes on a regular basis (e.g. once a week).

If fragmentation is between 10 and 30% we can use `REORGANIZE` to fix it. If it is above 30% we should use `REBUILD`.

We can perform index maintenance using "Index Maintenance Wizard" in SSMS (not recommended).

We might consider something better like Ola Hallengren's scripts.

## 4. Maintaining Columnstore Indexes

Columnstore indexes are quite different from rowstore indexes. So they require different maintenance.

### Why Columnstore Indexes Need Maintenance

Main reason why we need to maintain columnstore indexes is because of the deltastore and deleted list which are used to store the changes to the data.

To identify the indexes with many inserts (open row groups) we can use:

```sql
SELECT OBJECT_SCHEMA_NAME(rg.object_id) AS SchemaName,
       OBJECT_NAME(rg.object_id) AS TableName,
       i.name AS IndexName,
       i.type_desc AS IndexType,
       rg.partition_number,
       rg.row_group_id,
       rg.total_rows,
       rg.size_in_bytes,
       rg.deleted_rows,
       rg.[state],
       rg.state_description
FROM sys.column_store_row_groups AS rg
    INNER JOIN sys.indexes AS i ON i.object_id = rg.object_id AND i.index_id = rg.index_id
WHERE state_description != 'TOMBSTONE'
ORDER BY TableName,
         IndexName,
         rg.partition_number,
         rg.row_group_id;
```

To identify the indexes with a lot deleted rows (also together with deltastore modified rows), we can use:

```sql
SELECT OBJECT_SCHEMA_NAME(rg.object_id) AS SchemaName,
       OBJECT_NAME(rg.object_id) AS TableName,
       i.name AS IndexName,
       i.type_desc AS IndexType,
       rg.partition_number,
       rg.state_description,
       COUNT(*) AS NumberOfRowgroups,
       SUM(rg.total_rows) AS TotalRows,
       SUM(rg.size_in_bytes) AS TotalSizeInBytes,
       SUM(rg.deleted_rows) AS TotalDeletedRows
FROM sys.column_store_row_groups AS rg INNER JOIN sys.indexes AS i ON i.object_id = rg.object_id AND i.index_id = rg.index_id
GROUP BY rg.object_id,
         i.name,
         i.type_desc,
         rg.partition_number,
         rg.state_description
ORDER BY TableName,
         IndexName,
         rg.partition_number;
```

Columnstore indexes need maintenance because of the following reasons:

- **uncompressed rowgroups** - uncompressed rowgroups are B-tree structure which is slower than compressed rowgroups,
- **deleted rows** - deletes in a columnstore are logical, rows are flagged as deleted, but they are not removed from the index,
- **undersized rowgroups** - the ideal number of rows in a rowgroup is 1 million.

### Effects of Rebuild and Reorganize on Columnstore Indexes

For columnstore indexes we can use the very same commands as for the rowstore indexes, that is: `REORGANIZE` and `REBUILD`.

Rebuild for a columnstore index completely recreates the index. All resulting rowgroups will be compressed. All deleted rows will be removed. This operation can take a long time to complete and is very memory intensive, it would also use a lot of log space.

Because of that most of the time we would use `REORGANIZE` to maintain columnstore indexes. Reorganize
compresses all CLOSED rowgroups. Removes deleted rows if > 10% rows in a rowgroup are deleted. Combines compressed rowgroups up to row maximum. This operation is much faster than rebuild and is less memory intensive.

## 5. Maintaining Statistics

> Statistics are used by the query optimizer to determine the best way to execute a query.

### What are Statistics

Statistics are:

- aggregated data about data in table,
- measure of uniqueness of column,
- distribution of data within columns,
- not kept in sync with the table.

Statistics are very important for the query optimizer. They are used to determine the best way to execute a query.
That includes estimated rows affected and data sizes for a given query. Thus in result allow optimizer to choose appropriate
operators for the number of rows and calculate memory needed to run query.

### Why Statistics Need Maintenance

Over time statistics can become inaccurate. This can happen because of the data changes: inserts, updates, deletes, etc.

In result we can experience:

- slow queries,
- high CPU usage,
- excessive IOs,
- spills to TempDB.

To identify statistics that need maintenance we can use:

```sql
DBCC SHOW_STATISTICS (NULL, NULL, NULL, NULL, 'LIMITED');
```

### How Statistics Get Updated

Normally statistics are updated automatically by SQL Server.

Automatic statistics update is triggered after a certain number of changes to the underlying table.
Update occurs the next time the stats are needed. This is called "lazy update". It is sampled update
on large tables.

Statistics are also updated during index rebuild.

We can also update statistics manually using `UPDATE STATISTICS` command.

To check if statistics would be updated automatically we can use:

```sql
SELECT name,
       is_auto_update_enabled,
       is_auto_created,
       last_updated
FROM sys.stats
WHERE is_auto_update_enabled = 1
ORDER BY name;
```

To check if a database has enabled automatic statistics update we can use:

```sql
SELECT name,
       is_auto_update_enabled
FROM sys.databases
```

To update statistics we can use:

```sql
UPDATE STATISTICS <table_name> WITH FULLSCAN;
```

It is recommended to perform some kind of statistics maintenance on a regular basis, if you have time, update all stats with full scan every night. Don't over-do stats maintenance (it is difficult, but doable). Updating stats will invalidate query execution plan cache. Don't do sampled stats update after index rebuild!

This can be done using Microsoft's "Statistics Maintenance Wizard" or (preferred) Ola Hallengren's scripts.

## Summary

More info about index maintenance can be found [here](https://learn.microsoft.com/en-us/sql/relational-databases/indexes/reorganize-and-rebuild-indexes?view=sql-server-ver15).

More info about statistics maintenance can be found [here](https://learn.microsoft.com/en-us/sql/relational-databases/statistics/statistics?view=sql-server-ver15).

Ola Hallengren maintenance scripts can be found [here](https://ola.hallengren.com/sql-server-index-and-statistics-maintenance.html).
